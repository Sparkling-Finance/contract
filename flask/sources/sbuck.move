module flask::sbuck {

    use sui::coin::{Self, Coin, TreasuryCap};
    use sui::balance::{Self, Balance, Supply};
    use sui::url;

    use flask::utils;
    use flask::event;
    
    const ERR_WRONG_VERSION: u64 = 1;
    const ERR_ZERO_VALUE: u64 = 101;
    const ERR_INSUFFICIENT_DEPOSIT: u64 = 102;
    const ERR_UNMATCHED_FLASK: u64 = 103;

    const VERSIOIN: u64 = 1;

    const SBUCK_DECIMALS: u8 = 9;

    // OTW
    public struct SBUCK has drop {}
    
    public struct Flask<phantom T> has key{
        id: UID,
        version: u64,
        reserves: Balance<T>,
        sbuck_supply: Supply<SBUCK>
    }

    fun assert_pacakge_version<T>(self: &Flask<T>){
        assert!(self.version == VERSIOIN, ERR_WRONG_VERSION);
    }

    // === Getter ===
    public fun reserves<T>(self: &Flask<T>):u64{
        balance::value(&self.reserves)
    }
    public fun sbuck_supply<T>(self: &Flask<T>):u64{
        balance::supply_value(&self.sbuck_supply)
    }
    public fun reserves_to_supply<T>(self: &Flask<T>):u64{
        reserves(self) / sbuck_supply(self)
    }
    public fun claimable<T>(
        self: &Flask<T>,
        shares: u64
    ):u64
    {
        if(shares > reserves(self)) return 0;
        utils::mul_div(shares, reserves(self), sbuck_supply(self))
    }

    fun init(witness: SBUCK, ctx: &mut TxContext){
        let (sbuck_treasury_cap, sbuck_metadata) = coin::create_currency(
            witness,
            SBUCK_DECIMALS,
            b"sBUCK",
            b"Savings BUCK",
            b"yield bearing stablecoin receive the yield generated by Bucket protocol",
            option::some(url::new_unsafe_from_bytes(
                b"https://ipfs.io/ipfs/QmSXhXefmyiwVYLvHNrkXMkY46U1Z7GDGz66Lhoo4Bz3Cx"),
            ),
            ctx,
        );
        transfer::public_transfer(sbuck_treasury_cap, tx_context::sender(ctx));
        transfer::public_freeze_object(sbuck_metadata);
    }

    #[test_only] 
    public fun init_for_testing(ctx: &mut TxContext){init(SBUCK{}, ctx)}

    // consume treasury cap to create Supply
    entry public fun initialize<T>(
        sbuck_treasury_cap: TreasuryCap<SBUCK>,
        ctx: &mut TxContext
    ){
        let flask = Flask<T>{
            id: object::new(ctx),
            version: VERSIOIN,
            reserves: balance::zero<T>(),
            sbuck_supply: coin::treasury_into_supply(sbuck_treasury_cap)
        };

        transfer::share_object(flask);
    }

    public fun collect_rewards<T>(
        self: &mut Flask<T>,
        rewards: Balance<T>
    ){
        assert_pacakge_version(self);
        let rewards_val = balance::value(&rewards);
        assert!(rewards_val > 0, ERR_ZERO_VALUE);
        
        balance::join(&mut self.reserves, rewards);

        event::collect_rewards(rewards_val);
    }

    public fun deposit<T>(
        self: &mut Flask<T>,
        deposit: Coin<T>
    ):Balance<SBUCK>{
        assert_pacakge_version(self);
        let deposit_val = coin::value(&deposit);
        assert!(deposit_val > 0, ERR_ZERO_VALUE);
        
        let supply = sbuck_supply(self);
        let minted_sbuck_val= if(supply == 0){
            deposit_val
        }else{
            utils::mul_div(deposit_val, sbuck_supply(self), reserves(self))
        };

        assert!(minted_sbuck_val > 0, ERR_INSUFFICIENT_DEPOSIT);

        coin::put(&mut self.reserves, deposit);
        let sbuck_bal = balance::increase_supply(&mut self.sbuck_supply, minted_sbuck_val);
        event::deposit(deposit_val, balance::value(&sbuck_bal));

        sbuck_bal
    }

    public fun withdraw<T>(
        self: &mut Flask<T>,
        shares: Coin<SBUCK>
    ):Balance<T>{
        let shares_val = coin::value(&shares);
        assert!(shares_val > 0, ERR_ZERO_VALUE);

        // calculate claimed rewards
        let claimable = utils::mul_div(shares_val, reserves(self), sbuck_supply(self));
        let sbuck_val = balance::decrease_supply(&mut self.sbuck_supply, coin::into_balance(shares));

        let claimed_buck = balance::split(&mut self.reserves, claimable);

        event::burn(sbuck_val, balance::value(&claimed_buck));
        
        claimed_buck
    }
}

